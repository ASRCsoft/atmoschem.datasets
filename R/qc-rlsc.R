# QC-RLSC (quality control, robust loess signal correction)

# Loess smoothing applied to piecewise subsets of the data. Unlike the regular
# loess function, `span` is specified as the number of observations in a
# smoothing window
#' @export
piecewise_loess = function(formula, data, breaks, left.open = FALSE,
                           span = .75 * nrow(data), degree = 2, ...) {
  x = all.vars(formula)[2]
  res = list(x = x, breaks = breaks, left.open = left.open, span = span,
             degree = degree)
  if (!inherits(data, 'data.frame')) stop('not a data frame')
  if (!x %in% names(data)) stop('data is missing variable "x"')
  segment = findInterval(data[[x]], breaks, left.open = left.open)
  # Keep track of occasional numerical issue (reciprocal condition number is
  # zero) that can arise due to clusters of outliers in narrow spans. Based on
  # warning messages generated by the fortran source code here:
  # https://github.com/SurajGupta/r-source/blob/a28e609e72ed7c47f6ddfbb86c85279a0750f0b7/src/library/stats/src/loessf.f#L383
  singular_rcond = numeric()
  singular_at = numeric()
  catch_singular = function(w) {
    txt = conditionMessage(w)
    if (startsWith(txt, 'pseudoinverse used at')) {
      sing_x = as.numeric(sub('pseudoinverse used at ', '', txt))
      singular_at <<- c(singular_at, sing_x)
    } else if (startsWith(txt, 'reciprocal condition number')) {
      txt_rcond = as.numeric(sub('reciprocal condition number  ', '', txt))
      singular_rcond <<- c(singular_rcond, txt_rcond)
    }
    invokeRestart("muffleWarning")
  }
  res$loess = by(data, segment, function(seg_data) {
    # Argument `span` is dependent on the number of values. Since segments only
    # include a subset of the values, span has to be adjusted for each in order
    # to be applied consistently. Some care is required since missing values
    # will be removed (na.omit)
    n = nrow(na.omit(seg_data[, all.vars(formula)]))
    seg_span = span / n
    try(withCallingHandlers({
      loess(formula, seg_data, ..., span = seg_span, degree = degree)
    }, warning = catch_singular), silent = TRUE)
  })
  res$singular = data.frame(x = singular_at, rcond = singular_rcond)
  class(res) = 'piecewise_loess'
  res
}

#' @export
predict.piecewise_loess = function(fit, newdata) {
  # get the relevant segments and predict
  xsegments = findInterval(newdata[[fit$x]], fit$breaks,
                           left.open = fit$left.open)
  res = rep(NA, nrow(newdata))
  segments = intersect(as.character(unique(xsegments)), names(fit$loess))
  for (s in segments) {
    if (inherits(fit$loess[[s]], 'loess')) {
      i = which(xsegments == s)
      res[i] = predict(fit$loess[[s]], newdata[i, ])
    }
  }
  # Some segments may not have had data available for fitting a model. In that
  # case, predict the mean y value?
  # message(100 * sum(is.na(res)) / length(res), '% unpredicted')
  if (any(is.na(res))) {
    loesses = fit$loess[sapply(fit$loess, inherits, what = 'loess')]
    meany = mean(unlist(lapply(loesses, getElement, name = 'y')), na.rm = T)
    res[is.na(res)] = meany
  }
  res
}

#' @export
update.piecewise_loess = function(object, ...) {
  for (l in object$loess) update(l, ...)
  object
}

#' @export
print.piecewise_loess = function(x) {
  cat('Piecewise loess curve\n')
  cat('Segment lengths:\n')
  print(summary(sapply(x$loess, function(y) length(y$x))))
  invisible(x)
}

#' @export
plot.piecewise_loess = function(fit) {
  x = unlist(lapply(fit$loess, function(x) {
    if ('x' %in% names(x)) x[['x']] else numeric()
  }))
  y = unlist(lapply(fit$loess, function(x) {
    if ('y' %in% names(x)) x[['y']] else numeric()
  }))
  plot(x, y, col = rgb(0, 0, 0, .3))
  abline(v = fit$breaks)
  for (i in seq_along(fit$loess)) {
    if (inherits(fit$loess[[i]], 'loess')) {
      loess_i = fit$loess[[i]]
      curve_i = predict(loess_i, se = TRUE)
      # lines(loess_i$x, loess_i$fitted)
      lines(loess_i$x, curve_i$fit)
      lines(loess_i$x, curve_i$fit + curve_i$se, lty = 'dashed')
      lines(loess_i$x, curve_i$fit - curve_i$se, lty = 'dashed')
    }
  }
}

fit_loess = function(formula, data, par, left.open = TRUE) {
  # specifying `left.open = TRUE` because corrections are typically applied
  # immediately following a calibration check, so that the measured value at the
  # time of a correction should fall into the previous segment
  breaks = data$time[data$corrected]
  if (is.null(par)) {
    # choose degrees/spans with 5-fold cross validation
    cv = cvTools::cvTuning(piecewise_loess, formula, data,
                           tuning = list(degree = 0:2, span = 3:50),
                           args = list(breaks, left.open, family = 'symmetric'),
                           cost = cvTools::mape)
    par = as.integer(cv$tuning[cv$best, ])
  }
  piecewise_loess(formula, data, breaks, left.open = left.open, span = par[2],
                  degree = par[1], family = 'symmetric')
}

#' @export
qcrlsc_fit = function(formula, data, zpar = NULL, spar = NULL, cepar = NULL, smin = 0,
                      cemin = 0) {
  res = list(formula = formula)
  y = all.vars(formula)[1]
  # time must be converted to numeric for loess
  data$ntime = as.numeric(data$time)
  has_zeros = 'zero' %in% data$type
  has_spans = 'span' %in% data$type
  has_ces = 'CE' %in% data$type
  if (has_zeros) {
    res$zero = fit_loess(formula, subset(data, type == 'zero'), zpar)
  }
  if (has_spans) {
    spans = subset(data, type == 'span')
    # zero-correct the measured span values
    if (has_zeros) spans[, y] = spans[, y] - predict(res$zero, spans)
    # convert the measured value to a ratio
    spans[, y] = spans[, y] / spans$provided
    spans = spans[spans[, y] > smin, ]
    res$span = fit_loess(formula, spans, spar)
  }
  if (has_ces) {
    ces = subset(data, type == 'CE')
    # zero- and span-correct the measured values
    if (has_zeros) ces[, y] = ces[, y] - predict(res$zero, ces)
    if (has_spans) ces[, y] = ces[, y] / predict(res$span, ces)
    # convert the measured value to a ratio
    ces[, y] = ces[, y] / ces$provided
    ces = ces[ces[, y] > cemin, ]
    res$CE = fit_loess(formula, ces, cepar)
  }
  class(res) = 'qc_rlsc'
  res
}

#' @export
qcrlsc_correct = function(fit, x, y) {
  res = y
  newdata = data.frame(x = x)
  names(newdata) = all.vars(fit$formula)[-1]
  if ('zero' %in% names(fit)) res = res - predict(fit$zero, newdata)
  if ('span' %in% names(fit)) res = res / predict(fit$span, newdata)
  if ('CE' %in% names(fit)) res = res / predict(fit$CE, newdata)
  res
}

#' @export
print.qc_rlsc = function(x) {
  cat('QC-LSRC\n')
  fits = x[names(x) %in% c('zero', 'span', 'CE')]
  print(sapply(fits, function(y) y[c('degree','span')]))
  invisible(x)
}

# plot the loess curves
#' @importFrom ggplot2 autoplot
#' @method autoplot qc_rlsc
#' @export
autoplot.qc_rlsc = function(fit) {
  curve_types = names(fit)[names(fit) %in% c('zero', 'span', 'CE')]
  curves = fit[curve_types]
  # need columns x, y, type, segment (group)
  
  # scatterplot of cals
  cal_points = lapply(curves, function(l) {
    x = unlist(lapply(l$loess, function(x) {
      if ('x' %in% names(x)) x[['x']] else numeric()
    }))
    y = unlist(lapply(l$loess, function(x) {
      if ('y' %in% names(x)) x[['y']] else numeric()
    }))
    segment = findInterval(x, l$breaks, left.open = l$left.open)
    data.frame(x = x, y = y, segment = segment)
  })
  for (i in seq_along(cal_points)) cal_points[[i]]$type = curve_types[i]
  pointsdf = do.call(rbind, cal_points)

  # line/areas for loess curves
  linesdf = pointsdf
  linesdf$y = NA
  for (type in curve_types) {
    type_rows = linesdf$type == type
    # newdata = linesdf[type_rows, 'x', drop = FALSE]
    linesdf$y[type_rows] =
      predict(fit[[type]], data.frame(ntime = linesdf$x[type_rows]))
  }

  # break lines
  cal_breaks = lapply(curves, function(l) data.frame(x = l$breaks))
  # cal_breaks = cal_breaks[lengths(cal_breaks)]
  for (i in seq_along(cal_breaks)[sapply(cal_breaks, nrow) > 0]) {
    cal_breaks[[i]]$type = curve_types[i]
  }
  breaksdf = do.call(rbind, cal_breaks)

  ggplot2::ggplot(pointsdf, aes(x, y, group = segment)) +
    ggplot2::geom_point(size = 1, alpha = .5) +
    ggplot2::geom_line(data = linesdf, size = 1) +
    ggplot2::geom_vline(aes(xintercept = x), breaksdf) +
    ggplot2::facet_wrap(~ type, ncol = 1, scales = 'free_y',
                        strip.position = 'right')
}
